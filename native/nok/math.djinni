vec2i = interface +c {
    get_x(): i32;
    get_y(): i32;

    set_x(x: i32);
    set_y(y: i32);

    add(v: vec2i);
    addScaledVector(v: vec2i);
    sub(v: vec2i);
    multiply(i: i32);
    divide(i: i32);

    squareLength(): i32;
    getLength(): i32;
    setLength(length: i32);

    normalize(): vec2i;
    isZero(): bool;

    get(i: i32): i32;
    set(i: i32, v:i32);

    dot(v: vec2i): i32;
    cross(v: vec2i): vec2i;

    distance(v: vec2i): i32;

    static create(x: i32, y: i32): vec2i;
}

vec3i = interface +c {
    get_x(): i32;
    get_y():i32;
    get_z():i32;

    set_x(x: i32);
    set_y(y: i32);
    set_z(z: i32);

    add(v: vec3i);
    addScaledVector(v: vec3i);
    sub(v: vec3i);
    multiply(i: i32);
    divide(i: i32);

    squareLength(): i32;
    getLength(): i32;
    setLength(length: i32);

    normalize(): vec3i;
    isZero(): bool;

    get(i: i32): i32;
    set(i: i32, v:i32);

    dot(v: vec3i): i32;
    cross(v: vec3i): vec3i;

    distance(v: vec3i): i32;

    static create(x: i32, y: i32, z: i32): vec3i;
}

vec4i = interface +c {
    get_x(): i32;
    get_y():i32;
    get_z():i32;

    set_x(x: i32);
    set_y(y: i32);
    set_z(z: i32);
    set_w(w: i32);

    add(v: vec4i);
    addScaledVector(v: vec4i);
    sub(v: vec4i);
    multiply(i: i32);
    divide(i: i32);

    squareLength(): i32;
    getLength(): i32;
    setLength(length: i32);

    normalize(): vec4i;
    isZero(): bool;

    get(i: i32): i32;
    set(i: i32, v:i32);

    dot(v: vec4i): i32;
    cross(v: vec4i): vec4i;

    distance(v: vec4i): i32;

    static create(x: i32, y: i32, z: i32): vec4i;
}



vec2 = interface +c {
    get_x(): f32;
    get_y(): f32;

    set_x(x: f32);
    set_y(y: f32);

    add(v: vec2);
    addScaledVector(v: vec2);
    sub(v: vec2);
    multiply(i: f32);
    divide(i: f32);

    squareLength(): f32;
    getLength(): f32;
    setLength(length: f32);

    normalize(): vec2;
    isZero(): bool;

    get(i: f32): f32;
    set(i: f32, v:f32);

    dot(v: vec2): f32;
    cross(v: vec2): vec2;

    distance(v: vec2): f32;

    static create(x: f32, y: f32): vec2;
}

vec3 = interface +c {
    get_x(): f32;
    get_y(): f32;
    get_z(): f32;

    set_x(x: f32);
    set_y(y: f32);
    set_z(z: f32);

    add(v: vec3);
    addScaledVector(v: vec3);
    sub(v: vec3);
    multiply(i: f32);
    divide(i: f32);

    squareLength(): f32;
    getLength(): f32;
    setLength(length: f32);

    normalize(): vec3;
    isZero(): bool;

    get(i: f32): f32;
    set(i: f32, v:f32);

    dot(v: vec3): f32;
    cross(v: vec3): vec3;

    distance(v: vec3): f32;

    static create(x: f32, y: f32, z: f32): vec3;
}

vec4 = interface +c {
    get_x(): f32;
    get_y():f32;
    get_z():f32;

    set_x(x: f32);
    set_y(y: f32);
    set_z(z: f32);
    set_w(w: f32);

    add(v: vec4);
    addScaledVector(v: vec4);
    sub(v: vec4);
    multiply(i: f32);
    divide(i: f32);

    squareLength(): f32;
    getLength(): f32;
    setLength(length: f32);

    normalize(): vec4;
    isZero(): bool;

    get(i: f32): f32;
    set(i: f32, v:f32);

    dot(v: vec4): f32;
    cross(v: vec4): vec4;

    distance(v: vec4): f32;

    invert();
    static create(x: f32, y: f32, z: f32): vec4;
}

vec2d = interface +c {
    get_x(): f64;
    get_y(): f64;

    set_x(x: f64);
    set_y(y: f64);

    add(v: vec2d);
    addScaledVector(v: vec2d);
    sub(v: vec2d);
    multiply(i: f64);
    divide(i: f64);

    squareLength(): f64;
    getLength(): f64;
    setLength(length: f64);

    normalize(): vec2d;
    isZero(): bool;

    get(i: f64): f64;
    set(i: f64, v:f64);

    dot(v: vec2d): f64;
    cross(v: vec2d): vec2d;

    distance(v: vec2d): f64;

    invert();
    static create(x: f64, y: f64): vec2d;
}

vec3d = interface +c {
    get_x(): f64;
    get_y(): f64;
    get_z(): f64;

    set_x(x: f64);
    set_y(y: f64);
    set_z(z: f64);

    add(v: vec3d);
    addScaledVector(v: vec3d);
    sub(v: vec3d);
    multiply(i: f64);
    divide(i: f64);

    squareLength(): f64;
    getLength(): f64;
    setLength(length: f64);

    normalize(): vec3d;
    isZero(): bool;

    get(i: f64): f64;
    set(i: f64, v:f64);

    dot(v: vec3d): f64;
    cross(v: vec3d): vec3d;

    distance(v: vec3d): f64;

    invert();
    static create(x: f64, y: f64, z: f64): vec3d;
}

vec4d = interface +c {
    get_x(): f64;
    get_y(): f64;
    get_z(): f64;

    set_x(x: f64);
    set_y(y: f64);
    set_z(z: f64);
    set_w(w: f64);

    add(v: vec4d);
    addScaledVector(v: vec4d);
    sub(v: vec4d);
    multiply(i: f64);
    divide(i: f64);

    squareLength(): f64;
    getLength(): f64;
    setLength(length: f64);

    normalize(): vec4d;
    isZero(): bool;

    get(i: f64): f64;
    set(i: f64, v:f64);

    dot(v: vec4d): f64;
    cross(v: vec4d): vec4d;

    distance(v: vec4d): f64;

    invert();
    static create(x: f64, y: f64, z: f64): vec4d;
}


mat2 = interface +c {
    const width: f32 = 2;
    const height: f32 = 2;


    get(row: f32, col: f32):f32;
    set(row: f32, col: f32, v: f32);

    static orthogonalProjection(left: f32, right: f32, bottom: f32, top: f32, zn: f32, zf: f32): mat2;
    static perspective(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): mat2;
    static perspectiveFOV(fov: f32, aspect: f32, near: f32, far: f32): mat2;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat2;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat2;

    static translation(x: f32, y: f32): mat2;
    static movement(x: f32, y: f32, z: f32):mat2;
    static identity(): mat2;
    static scale(scale: f32): mat2;
    
    static rotationX(alpha: f32): mat2;
    static rotationY(alpha: f32): mat2;
    static rotationZ(alpha: f32): mat2;

    static rotation(yaw: f32, pitch: f32, roll: f32): mat2;

    static create(): mat2;

    static from(mat: mat2): mat2;

    add(mat: mat2): mat2;
    sub(mat: mat2): mat2;

    multiply(i: f32): mat2;
    clone(): mat2;
    transpose(): mat2;
    transpose3x3(): mat2;
    trace(): f32;
    determinant(): f32;

    static linearInterpolate(a: mat2, b: mat2, prop: f32): mat2;
}


mat3 = interface +c {
    const width: f32 = 3;
    const height: f32 = 3;


    get(row: f32, col: f32):f32;
    set(row: f32, col: f32, v: f32);

    static orthogonalProjection(left: f32, right: f32, bottom: f32, top: f32, zn: f32, zf: f32): mat3;
    static perspective(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): mat3;
    static perspectiveFOV(fov: f32, aspect: f32, near: f32, far: f32): mat3;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat3;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat3;

    static translation(x: f32, y: f32): mat3;
    static movement(x: f32, y: f32, z: f32):mat3;
    static identity(): mat3;
    static scale(scale: f32): mat3;
    
    static rotationX(alpha: f32): mat3;
    static rotationY(alpha: f32): mat3;
    static rotationZ(alpha: f32): mat3;

    static rotation(yaw: f32, pitch: f32, roll: f32): mat3;

    static create(): mat3;

    static from(mat: mat3): mat3;

    add(mat: mat3): mat3;
    sub(mat: mat3): mat3;

    multiply(i: f32): mat3;
    clone(): mat3;
    transpose(): mat3;
    transpose3x3(): mat3;
    trace(): f32;
    determinant(): f32;

    static linearInterpolate(a: mat3, b: mat3, prop: f32): mat3;
}



mat4 = interface +c {
    const width: f32 = 3;
    const height: f32 = 3;


    get(row: f32, col: f32):f32;
    set(row: f32, col: f32, v: f32);

    static orthogonalProjection(left: f32, right: f32, bottom: f32, top: f32, zn: f32, zf: f32): mat4;
    static perspective(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): mat4;
    static perspectiveFOV(fov: f32, aspect: f32, near: f32, far: f32): mat4;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat4;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat4;

    static translation(x: f32, y: f32): mat4;
    static movement(x: f32, y: f32, z: f32):mat4;
    static identity(): mat4;
    static scale(scale: f32): mat4;
    
    static rotationX(alpha: f32): mat4;
    static rotationY(alpha: f32): mat4;
    static rotationZ(alpha: f32): mat4;

    static rotation(yaw: f32, pitch: f32, roll: f32): mat4;

    static create(): mat4;

    static from(mat: mat4): mat4;

    add(mat: mat4): mat4;
    sub(mat: mat4): mat4;

    multiply(i: f32): mat4;
    clone(): mat4;
    transpose(): mat4;
    transpose3x3(): mat4;
    trace(): f32;
    determinant(): f32;

    static linearInterpolate(a: mat4, b: mat4, prop: f32): mat4;
}



mat2d = interface +c {
    const width: f64 = 2;
    const height: f64 = 2;


    get(row: f64, col: f64):f64;
    set(row: f64, col: f64, v: f64);

    static orthogonalProjection(left: f64, right: f64, bottom: f64, top: f64, zn: f64, zf: f64): mat2d;
    static perspective(left: f64, right: f64, top: f64, bottom: f64, near: f64, far: f64): mat2d;
    static perspectiveFOV(fov: f64, aspect: f64, near: f64, far: f64): mat2d;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat2d;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat2d;

    static translation(x: f64, y: f64): mat2d;
    static movement(x: f64, y: f64, z: f64):mat2d;
    static identity(): mat2d;
    static scale(scale: f64): mat2d;
    
    static rotationX(alpha: f64): mat2d;
    static rotationY(alpha: f64): mat2d;
    static rotationZ(alpha: f64): mat2d;

    static rotation(yaw: f64, pitch: f64, roll: f64): mat2d;

    static create(): mat2d;

    static from(mat: mat2d): mat2d;

    add(mat: mat2d): mat2d;
    sub(mat: mat2d): mat2d;

    multiply(i: f64): mat2d;
    clone(): mat2d;
    transpose(): mat2d;
    transpose3x3(): mat2d;
    trace(): f64;
    determinant(): f64;

    static linearInterpolate(a: mat2d, b: mat2d, prop: f64): mat2d;
}


mat3d = interface +c {
    const width: f64 = 3;
    const height: f64 = 3;


    get(row: f64, col: f64):f64;
    set(row: f64, col: f64, v: f64);

    static orthogonalProjection(left: f64, right: f64, bottom: f64, top: f64, zn: f64, zf: f64): mat3d;
    static perspective(left: f64, right: f64, top: f64, bottom: f64, near: f64, far: f64): mat3d;
    static perspectiveFOV(fov: f64, aspect: f64, near: f64, far: f64): mat3d;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat3d;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat3d;

    static translation(x: f64, y: f64): mat3d;
    static movement(x: f64, y: f64, z: f64):mat3d;
    static identity(): mat3d;
    static scale(scale: f64): mat3d;
    
    static rotationX(alpha: f64): mat3d;
    static rotationY(alpha: f64): mat3d;
    static rotationZ(alpha: f64): mat3d;

    static rotation(yaw: f64, pitch: f64, roll: f64): mat3d;

    static create(): mat3d;

    static from(mat: mat3d): mat3d;

    add(mat: mat3d): mat3d;
    sub(mat: mat3d): mat3d;

    multiply(i: f64): mat3d;
    clone(): mat3d;
    transpose(): mat3d;
    transpose3x3(): mat3d;
    trace(): f64;
    determinant(): f64;

    static linearInterpolate(a: mat3d, b: mat3d, prop: f64): mat3d;
}



mat4d = interface +c {
    const width: f64 = 4;
    const height: f64 = 4;


    get(row: f64, col: f64):f64;
    set(row: f64, col: f64, v: f64);

    static orthogonalProjection(left: f64, right: f64, bottom: f64, top: f64, zn: f64, zf: f64): mat4d;
    static perspective(left: f64, right: f64, top: f64, bottom: f64, near: f64, far: f64): mat4d;
    static perspectiveFOV(fov: f64, aspect: f64, near: f64, far: f64): mat4d;

    static lookAt(eye: vec3i, at: vec3i, up: vec3i): mat4d;
    static lookAlong(axis: vec3i, eye: vec3i, up: vec3i): mat4d;

    static translation(x: f64, y: f64): mat4d;
    static movement(x: f64, y: f64, z: f64):mat4d;
    static identity(): mat4d;
    static scale(scale: f64): mat4d;
    
    static rotationX(alpha: f64): mat4d;
    static rotationY(alpha: f64): mat4d;
    static rotationZ(alpha: f64): mat4d;

    static rotation(yaw: f64, pitch: f64, roll: f64): mat4d;

    static create(): mat4d;

    static from(mat: mat4d): mat4d;

    add(mat: mat4d): mat4d;
    sub(mat: mat4d): mat4d;

    multiply(i: f64): mat4d;
    clone(): mat4d;
    transpose(): mat4d;
    transpose3x3(): mat4d;
    trace(): f64;
    determinant(): f64;

    static linearInterpolate(a: mat4d, b: mat4d, prop: f64): mat4d;
}



quaternion = interface +c {
    static create(x: f32, y: f32, z: f32, w: f32): quaternion;
    static fromAxis(axis: vec3, radian: f32): quaternion;
    slerp(t: f32, q: quaternion): quaternion;
    rotated(b: quaternion): quaternion;
    scaled(scale: f32): quaternion;
    dot(q: quaternion): f32;
    matrix(): mat4;

    add(q: quaternion): quaternion;
    sub(q: quaternion): quaternion;

    addVec3(v: vec3): quaternion;
    multiply(q: quaternion): quaternion;

    normalize();
    rotate(q: quaternion);

    conjugate(): quaternion;
    invert(): quaternion;

    get_x(): f32;
    get_y(): f32;
    get_z(): f32;

    set_x(x: f32);
    set_y(y: f32);
    set_z(z: f32);
}