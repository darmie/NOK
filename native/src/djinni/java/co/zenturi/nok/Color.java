// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from nok.djinni

package co.zenturi.nok;

import java.util.concurrent.atomic.AtomicBoolean;

/** @import "audio.djinni" */
public abstract class Color {
    public static final double BLACK = 4278190080;

    public static final float WHITE = 4294967295;

    public static final float RED = 4294901760;

    public static final float BLUE = 4278190335;

    public static final float GREEN = 4278255360;

    public static final float MAGENTA = 4294902015;

    public static final float YELLOW = 4294967040;

    public static final float CYAN = 4278255615;

    public static final float PURPLE = 4286578816;

    public static final float PINK = 4294951115;

    public static final float ORANGE = 4294944000;

    public abstract float getR();

    public abstract float getG();

    public abstract float getB();

    public abstract float getA();

    public abstract void setR(float r);

    public abstract void setG(float g);

    public abstract void setB(float b);

    public abstract void setA(float a);

    public static Color create(double color)
    {
        return CppProxy.create(color);
    }

    private static final class CppProxy extends Color
    {
        private final long nativeRef;
        private final AtomicBoolean destroyed = new AtomicBoolean(false);

        private CppProxy(long nativeRef)
        {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
        }

        private native void nativeDestroy(long nativeRef);
        public void _djinni_private_destroy()
        {
            boolean destroyed = this.destroyed.getAndSet(true);
            if (!destroyed) nativeDestroy(this.nativeRef);
        }
        protected void finalize() throws java.lang.Throwable
        {
            _djinni_private_destroy();
            super.finalize();
        }

        @Override
        public float getR()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_getR(this.nativeRef);
        }
        private native float native_getR(long _nativeRef);

        @Override
        public float getG()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_getG(this.nativeRef);
        }
        private native float native_getG(long _nativeRef);

        @Override
        public float getB()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_getB(this.nativeRef);
        }
        private native float native_getB(long _nativeRef);

        @Override
        public float getA()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_getA(this.nativeRef);
        }
        private native float native_getA(long _nativeRef);

        @Override
        public void setR(float r)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_setR(this.nativeRef, r);
        }
        private native void native_setR(long _nativeRef, float r);

        @Override
        public void setG(float g)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_setG(this.nativeRef, g);
        }
        private native void native_setG(long _nativeRef, float g);

        @Override
        public void setB(float b)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_setB(this.nativeRef, b);
        }
        private native void native_setB(long _nativeRef, float b);

        @Override
        public void setA(float a)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_setA(this.nativeRef, a);
        }
        private native void native_setA(long _nativeRef, float a);

        public static native Color create(double color);
    }
}
